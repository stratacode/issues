<html extends="ArticlePage">
<head title="Motivation for Layers"/>

<body>
   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## The Motivation for Layers

Layers are as much a design pattern as language feature.  They introduce both a new hinge point to extend and reuse code and allow new ways for building and maintaining large, complex systems.  Layers are a new twist to object oriented programming, letting you refine a class or instance without renaming.   

## More Flexible Than Modules

Like modules, they are a packaging mechanism with dependencies.  We say that a layer may extend one or more other layers which ensures those other layers are below it in the stack..  Where you'd use a module before, you'll use a layer with StrataCode.  Unlike modules though, layers can be merged.  The process works like layers in Photoshop but where we merge by name, not pixel position.  

## Still Statically Typed
Layers preserve encapsulation and are statically typed, adhering to the <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID principles</a> of O/O design.  They may replace or add to an object's interface or override but cannot remove a previously defined contract.  They also cannot depend on a layer that comes after them in the current list of layers.  Just like Java, you have traceable code paths, edit time errors, find usages, refactoring and more.  They are similar to <a href="https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=2&cad=rja&ved=0CDYQFjAB&url=http%3A%2F%2Fdl.acm.org%2Fcitation.cfm%3Fid%3D1885647&ei=vLBRUsaBNaGqiAK7moCICA&usg=AFQjCNGUS5M8Ep_9HKm8GO_terTa9cMT_g&bvm=bv.53537100,d.cGE">Delta oriented programming</a> and can also be used for product feature-lines.

## Modules and Circular References

As modules grow in size, they tend to develop circular dependencies.  For example, Module A depends naturally on Module B but as the project grows, some minor aspect of B may develop a dependency on some minor aspect of A, possibly due to a poor modularization decision.  Refactoring to eliminate the circular dependency would work but breaks compatibility and so may not be an option.  Allowing the new circular dependency creates severe code management problems.  Conceptually now A and B must be updated in lockstep.  You lose many of the benefits of modularization in the first place.  Changes in B may depend on changes in A and vice versa.  It becomes impossible to test a new version of A with an old version of B and vice versa.  That reduces your ability to detect when the interfaces of your modules change in an incompatible way. 


## Layers Eliminate Circular References 

With layers, a downstream layer cannot refer to an upstream layer.  Code dependencies only go one way to preserve modularity as systems grow.  Instead, when you would need to add a cyclic dependencies, due to the addition of that minor feature, this code is added in a separate layer that extends both of the previous A and B layers.  It separates that minor dependency from the bulk of the code.  You retain the independence of the rest of the code without breaking APIs or compatibility.  If you want existing clients to see this new module, the new layer is named "A" and the old "A" is renamed.  If you want to offer this as an opt-in feature, you give the new layer a new name and tell clients to point to that layer to get that feature.

Languages like OCaml do not allow cyclic references between modules.  Unfortunately that inflexibility often requires refactoring that breaks compatibility when you need to refactor.  Layers give you the best of both worlds: enforcement of one-way dependencies in the core modular structure, and the ability to incrementally add cyclic relationships to types while keeping the code modular.  

The differences between modules and layers are shown in this diagram:
<% ) %>

<img style="margin:0px auto;display:block" src="images/deps.png" alt="Dependencies between Modules and Layers"/>

<%= MarkDownPage.markDown(%>
Here we need to add upstream dependencies to types C and E.  With layers we can do so without creating a hairball by modifying C and E in a new layer.  Also, we can move code between layers without changing the APIs seen by the supported layer.  If we move code between modules, we break APIs.

## Dealing with Complex Types

It's very difficult to keep two complex types in your system from developing a circular dependency between them.  The most intuitive types are built from natural entities in the system and two complex entities may need to depend on each other to implement certain features.  By splitting complex types into well organized layers, you can support these types of use cases beautifully, and make those large files easier to navigate as well.

## Mechanics of Layers

Like modules, layers may extend one or more other layers which they depend upon.  This exposes all of the types and instances in that layer to the extending layer.  Layers also can pass along imports to subsequent layers.  Each layer gets a nice sandbox of all of the types imported by the layers it extends.  Downstream code does not depend on the exact package name of an imported type, allowing you to easily substitute variants by adding an intermediate layer.

You typically run one layer which pulls in dependent layers automatically.  You might however specify a list of layers to run and all dependent layers are automatically sorted and included in the application.   Ultimately each collection of layers - a layered system - maintains a single ordered list of layers at any given time which are merged to form the "runtime view" of the application.

Some may see layers as being too powerful.  Each layer has too much control over the vast environment of the system.  Do you have to search all layers to find who might be changing a particular type?  To avoid this uncontrolled flexibility and help modularize layers, they have a package which is prepended onto the package of all files in the layer.   Layers can only create or modify types in their package.  Files do not specify the empty directories generally required by Java, nor do they need a package operator.  A final layer will not let you modify types in that layer, essentially turning it into a module to the outside world.

Layers can be delivered in compiled form or source form.  The dynamic and modify type features require layers in the source form.

## Why Layers?

Why objects, why methods, etc.  It's hard to describe why you should adopt a new language paradigm.  I came upon this design after 20+ years of refinement after building three large systems I was involved with for a long time.  ATG's nucleus, layers it's configuration system for runtime components ala spring but has no compiled component support.  

The most important benefits of layers show up when maintaining large customized systems, like those commonly found in enterprise development.  Layers help manage workflows for enterprise systems, separating design, administration, business rules, workflow, and code. 

When combined with StrataCode's declarative features, layers provide a hinge point for customizing any property of any object.  You can replace any DOM element of any HTML file.  Append to or replace any component.  Override any formula.  Though layers require some conceptual understanding, the IDE and management UI frameworks make it easy to build powerful, customizable applications.

## Pure Domain Models   

Your domain model specifies the data and core business rules.  Ideally this model is simple and independent from the rest of the system as it needs to be used where you are coding up a business process using that model.  But these are rich objects that collect code and dependencies rapidly.  Layering helps you preserve an independent version of your domain model.  Runtime dependencies likely will exist for in the generated code for your model classes - just not in the source.  Using annotations, base layers, base classes, etc. you can write powerful framework features to manipulate the code of your domain model so it's properly serialized, stored in a database, etc.  When necessary, you can modify your types using platform specific layers of your domain model.

Here's a simple domain model object:

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>class Quiz {
   String name;
   List<Question> questions; 
}
<% ) %>

Add JPA persistence with:

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>@Entity
@Table(name="quiz")
Quiz {
   // Primary key is the quiz name
   override @Id name;

   // Define a one to many relationship between a quiz and its
   // questions.  The questions will automatically be persisted when the
   // quiz is persisted.
   override @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER) questions;
}
<% ) %>
We could have added these annotations using a framework layer automatically but here you see how to add annotations to existing properties and methods from a layer. 
Just referring to a property in a layer adds that property to a list that's accessible to the framework.  This lets you set properties for the layer that apply to all properties in the layer.

To use a quiz, you might also initialize it:
<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>object ScienceQuiz extends Quiz {}

ScienceQuiz {
   name = "Science";

   questions {
      object question1 extends Question {
         question = "The galaxy we live in is called the Milky Way.  It is shaped\n" +
                    "approximately like:";
         answerChoices = { "A round ball", "A doughnut", "A pretzel", "A flat spiral" };
         answerIndex = 3;
         answerDetail = "The Milky Way has four spiral arms radiating out from a\n" +
                        "central cluster of stars (nucleus).  Our solar system is\n" +
                        "located on one of the spiral arms, quite far from the\n" +
                        "center.";
      }
   }
}
<% ) %>
Each layer is stored in a separate directory with parallel file names and path structure which can be swapped in and out of the application for different purposes.

Not only do you use layers to separate dependencies, you also use them to partition assets among people: business analysts, designers etc.  One person defines the data model, another manages persistence, a third manages business data and rules.  Layers help separate assets along role boundaries for better workflows.
 
## Styles and Design Elements

Style sheets separate configuration from code in a clean way and are very powerful but sometimes overkill and overly complicated.  How do you find and isolate the effects of a code change?  In a simpler model, the developer or framework provides specific customization hooks for a certain set of properties of either the types of UI components or specific instances.  Layers make this separation easier for both the programmer and designer.  The programmer exposes just the properties or components they think need customization.  If they are on classes, they are inherited.  If they are instances they are set on that specific widget instance.  The designer just needs to know the names of the class or object and property.  All of this is toolable because of strong typing, and Java's visibility rules.  

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>UnitConverter {
   foreground = Color.WHITE;
   background = Color.BLACK;
   errorLabel {
     foreground = Color.RED;
   }
}
<% ) %>

StrataCode's multiple inheritance feature lets you apply properties across the class hierarchy as well.  This gives you a strongly typed version of stylesheet's "class" selector.  Object names are analagos to the "id" selector.  

Designers require immediate updates to be applied so they can dial in the perfect colors, spacing, and overall appearance.

When it comes to deployment, styles may be compiled in for runtime efficiency or applied dynamically for flexibility by making the layer dynamic.

## Testing/Monitoring 

Customize classes to add logging, monitoring, performance hooks.  Inject test code and diagnostics into system classes in a maintainable way.  Make it easy to build with and without these hooks.  Though this code is separated, compile time errors and good tools will make it easy to keep the code in sync.  Separating it unclutters the program logic.  Here's a simple example of inserting monitoring code before and after some servlet:

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>MainProductionServlet {
  void service(ServletRequest request, ServletResponse response) {
    SystemMonitor.monitorStart("ProductionServlet");
    boolean success = false;
    try {
       super.service(reuqest, response);
       success = true;
    }
    finally {
       SystemMonitor.monitorEnd("ProductionServlet", success);
    }
  }
}
<% ) %>

Behind the scenes, StrataCode will create a new MainProductionServlet class when this testing layer is included.  It will use that class instead of the default one.  You can create layers which add much more testing and monitoring logic because it is isolated both from the core code and core runtime.

## Localization

You might create a layer for each locale variation.  With StrataCode, programmers define strings with static final/const variables and initialize them as they might normally.  You simply override those strings in sublayers.  At compile time, a new class is generated which replaces the original strings with the new strings.  You get a new efficient localized executable.

Strings can be compiled in for the smallest footprint or applied at runtime to allow dynamic language applications without code change.  Most systems that are localized use resource bundle implementations which are dynamic objects.  That adds to the library size, application code size, and data size required.  Particularly for mobile or internet apps, this can be significant as apps grow in size.  It also means resource bundles are not resolved until they are used.  It's safer to use normal language constructs and the code is easier to read.

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>MainAppPanel {
   welcomeMessage="Welcome {0}!";
}
<% ) %>

You might need to adjust UI spacing for a given language.  With StrataCode, one layer can manage all of these aspects making it easy to manage and build localized systems.

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>MainAppPanel {
   welcomeMessage = "Willkommen {0}!";
   leftSideWidth := windowSize * 0.25;
}
<% ) %>


<% ) %>
   </div>

   </div>
</body>

</html>
