<html extends="Example">
<head title="Program Editor Example"/>

<body>
   <div id="content">
      <div id="exampleContent" exec="server">

      <div class="exampleTitle">Program Editor Example</div>

      The program editor is the first real application written in StrataCode.  It's a bit too large to show here in its entirety but worth looking at the overall structure, and some key code slices.  It's the best example of how StrataCode scales to difficult problems.

      <table>
         <tr>
            <td>
               <a href="./images/swingEditor.png"><img src="./images/swingEditorIcon.png"></a><br>
               The swing version
            </td>
            <td>
               <a href="./images/jsEditor.png"><img src="./images/jsEditorIcon.png"></a><br>
               The schtml version
            </td>
         </tr>
      </table>

      <p>
      The program editor lives in the editor layer group.  It consists of several layers that total ~8000 lines of code.  It uses 350 forward binding expressions, 20 bi-directional bindings, 100 reverse bindings, and 150 object definitions.  
     </p>
      <p>
      It runs fully compiled or fully dynamic hybrid modes where the model is compiled and the UI is dynamic or vice versa.  The swing versionis demoed in both the Basic and Advanced demos listed in the <a href="videos.html">videos</a>.  The web framework has 2/3s of the functionality of the swing version working but soon will work like the swing version but in the browser.   You can view types flexibly in merged and layered views, control visibility based on code-complexity: declarative, application, framework or code-role: UI, database, admin, style, application.  In dynamic mode, when you change properties on interfaces using multiple inheritance, they propagate throughout the initialization tree.  You can create or remove objects, properties, or layers all without restarting.  When a restart is necessary, the restart icon lights up, a reason box describes the changes which requires a restart. 
     </p>
      <ul>
         <li>editor.model (849 Lines):  Defines the key data structures behind the program editor. This layer runs both in the browser and on the server and so represents the data structures that StrataCode synchronizes.  There is EditorModel which stores the current type and selection and TypeTreeModel, which implements the tree view itself.
         <li>editor.modelImpl (2000 lines): Runs just on the server in the client/server version.  This layer contains the logic which populates EditorModel and TypeTreeModel for any user interface.  It extends sys.layeredSystem in addition to the model layer.  Because sys.layeredSystem only runs on the server, this layer will only run on the server too.
         <li>editor.coreui (425 lines): Runs on both the client and the server.  Contains some core user-interface code shared by both swing and the Javascript layers.
         <li>editor.swing.core (2600 lines): Implements the Swing user interface.
         <li>editor.js.core (1000 lines): Implements the Javascript user interface.  Runs on both the client and the server.
      </ul>

      The swing user interface code is longer because it uses data binding for all layout (not ideal but not half bad!)  The JS version is only 2/3rd done but will end up doing the same thing with about half the code.  
      <p>
      There are substantial cross platform code savings.  Building the client/server app involved splitting up the existing classes into pieces that are put into new layers.  Code which depends on swing goes into the swing specific layer.  Code that depends on the server features, goes into that layer.  Code that does not depend on anything which is generic to all goes into the model layer.  
     </p>
      <p>Additionally, the complex data structures put into this model layer, which is shared by both the client and server runtimes, can serialize themselves back and forth seamlessly.  
     </p>
      
      <p>
      Here's the layer of EditorModel that is synchronized - i.e. shared on client and server:
     </p>
<%= sc.lang.SCLanguage.getSCLanguage().styleFile("editor/model","EditorModel.sc", false, false) %>

      Here the synchronized layer of TypeTreeModel:
<%= sc.lang.SCLanguage.getSCLanguage().styleFile("editor/model","TypeTreeModel.sc", false, false) %>

      Here's the server specific layer of EditorModel.  It responds to changes to some of its properties and sets others to create a dialog with the client.
<%= sc.lang.SCLanguage.getSCLanguage().styleFile("editor/modelImpl","EditorModel.sc", false, false) %>

      Here the server layer of TypeTreeModel:
<%= sc.lang.SCLanguage.getSCLanguage().styleFile("editor/modelImpl","TypeTreeModel.sc", false, false) %>

      <p>

      <div class="exampleTitle">Program Editor Synchronization</div>
     </p>
      <p>
      It's worth looking in detail on how synchronization works with this model.  Properties can be sent to the client either because they are registered globally or lazily when they are accessed by the top-level page object during rendering.   
      
     </p>
      <p>
      All of that information is sent to the client in the initial response so it can be used to populate Javascript objects.  It comes after the static HTML generated by the server tag objects.  The information serialized to the cilent can then be used by the Javascript code to update any portions of the UI that are not "server only" content in the first refresh.
      </p>
      <p>
      There's a lot of complex behavior, with only a few lines of explicit synchronization code.  It might seem like magic, but it's actually very easy to trace what's going on and make it do what you want by setting annotations and occasionally a using the API.  Data binding events are used to track synchronized property changes.  A method call to addS yncType is inserted to register the metadat and addSyncInst is used to signal a new instance of a given type was created that needs to be tracked.  Lazy references are processed when StrataCode serializes a reference to a new instance that has not been synchronized.  It can automatically synchronize it at that time.
     </p>
     <p>
      StrataCode makes it easy to follow what's going on.  It uses the SCLanguage to synchronize the client and server.  Instead of JSON, you see a layer of changes going back and forth.
     </p>
      <p>
      Here is the initial layer of data for the program editor in layer format (abbreviated to avoid repetition).  The program editor code defines UIIcons using the global mode so those come across first:
First send over global/static state:
      </p>
<pre class="code">
package sc.gui.util;
     
UIIcon {
   static sc.gui.util.UIIcon UIIcon__0 = new sc.gui.util.UIIcon("/sc/editor/", "images/class.gif", "Class");
}
UIIcon__0 {
   dir = "/sc/editor/";
   path = "images/class.gif";
   desc = "Class";
}

.... more icons ...
</pre>

      <p>
      Then comes the data which describes the LayeredSystem (the container for the current stack of layers), the layer info, the tree of available types in the system, and lazily pulls down the meta-data for a selected type.  These objects are marked as "on-demand".  The objects in the page we are loading refers to them.  That first reference causes them to be added to the layer.  They come across first because they do not depend on anything else.
      
<pre class="code">
package sc.layer;

object LayeredSystem__0 extends sc.layer.LayeredSystem {
}
package sc.editor;

EditorFrame.body.editorPanel.editorModel {
   system = sc.layer.LayeredSystem__0;
   currentTypeIsLayer = false;
   staleCompiledModel = false;
}
package sc.lang;

object JLineInterpreter__0 extends sc.lang.JLineInterpreter {
}

</pre>
      <p>
Then properties on the editorModel and typeTreeModel instances are set.  These are simple objects which extend the classes shown above:
     </p>
<pre class="code">
package sc.editor;

EditorFrame.body.editorPanel.editorModel {
   ctx = sc.lang.JLineInterpreter__0;
   triggeredByUndo = false;
   debugEnabled = true;
}
EditorFrame.body.editorPanel.typeTreeModel {
   system = sc.layer.LayeredSystem__0;
   typeListener = EditorFrame.body.editorPanel.trees.typeList.typeTree;
   layerListener = EditorFrame.body.editorPanel.trees.layerList.layerTree;
   object DirEnt__0 extends sc.editor.TypeTreeModel.DirEnt {
      imported = false;
      hasSrc = false;
      transparent = false;
      prependPackage = false;
      entries = {};
   }
   rootTypeDirEnt = EditorFrame.body.editorPanel.typeTreeModel.DirEnt__0;
   DirEnt__0 {
      type = TypeTreeModel.EntType.Root;
      value = "All Types";
      isTypeTree = true;
   }
   object TreeEnt__0 extends sc.editor.TypeTreeModel.TreeEnt {
      imported = false;
      hasSrc = false;
      transparent = false;
      prependPackage = false;
   }
   typeEmptyCommentNode = EditorFrame.body.editorPanel.typeTreeModel.TreeEnt__0;
   TreeEnt__0 {
      type = TypeTreeModel.EntType.Comment;
      value = "No visible types";
      isTypeTree = true;
   }

   ... Repeated for each tree entry...

</pre>
      <p>
When the UIColor node in the type tree is selected, the client sends down this:
<pre class="code">
package sc.editor;

EditorFrame.body.editorPanel.typeTreeModel.TreeEnt__5 {
   open = true;
   needsType = true;
   selected = true;
}
</pre>

      <p>
The server code modifies the TreeEnt class like this:
     </p>
<pre class="code">
   TreeEnt {
      // When needsType is true, we set the cachedTypeDeclaration property which syncs it to the client
      needsType =: fetchType();

      void fetchType() {
         if (needsType) {
            cachedTypeDeclaration = getTypeDeclaration();
            processEntry();
         }
      }
   }
</pre>
So when needsType is set to true, cachedTypeDeclaration gets populated with the data we need on the client.  The server tracks this change and puts this into the sync response:
<pre class="code">
object sc_type_UIColor__0 extends sc.lang.java.ClassDeclaration {
}
package sc.editor;

EditorFrame.body.editorPanel.typeTreeModel.TreeEnt__5 {
   cachedTypeDeclaration = sc_type_UIColor__0;
}
package ;

sc_type_UIColor__0 {
   typeName = "UIColor";
   layer = sc.layer.Layer__0;
   packageName = "sc.gui.util";
   dynamicType = false;
   isLayerType = false;
}
package sc.lang.java;

object VariableDefinition__0 extends sc.lang.java.VariableDefinition {
}
object VariableDefinition__1 extends sc.lang.java.VariableDefinition {
}
object VariableDefinition__2 extends sc.lang.java.VariableDefinition {
}
object VariableDefinition__3 extends sc.lang.java.VariableDefinition {
}
package ;

sc_type_UIColor__0 {
   allProperties = {sc.lang.java.VariableDefinition__0, sc.lang.java.VariableDefinition__1, sc.lang.java.VariableDefinition__2, sc.lang.java.VariableDefinition__3};
   declarationType = sc.lang.java.DeclarationType.CLASS;
}
package sc.lang.java;

VariableDefinition__0 {
   variableName = "class";
}
VariableDefinition__1 {
   variableName = "r";
   layer = sc.layer.Layer__0;
}
VariableDefinition__2 {
   variableName = "g";
   layer = sc.layer.Layer__0;
}
VariableDefinition__3 {
   variableName = "b";
   layer = sc.layer.Layer__0;
}
</pre>

      <p>
With the StrataCode serialization protocol, not only does it serialize your data, it also wires together a complete graph of objects.  It then monitors changes to those objects and exchanges deltas back and forth.
     </p>
<p>
The StrataCode serialization protocol is translated to Javascript on the server and is shipped to the client as Javascript code.  The client eval's this script to apply the changes.  You can even set breakpoints to walk through the deserialization. 
</p><p>
A binary protocol for the sync system is planned to make large volume data transfers more efficient.
     </p>

      <div class="exampleTitle">Tree Widget</div>

Here's the tree widget, used to generate the HTML for each of the two tree's in StrataCode.  It shows data binding expressions being used to define the content and behavior of the tree.  Data binding is used to choose the CSS classes for each tag.  It's used to make tags visible/invisible.  To conditionally render an icon for the node in the tree. 
     </p>
<%= sc.lang.HTMLLanguage.INSTANCE.styleFile("editor/js/core", "TreeView.schtml", false, false) %>
Look at the tag has the repeat attribute.  It extends the TreeView component - i.e. it extends its enclosing class. That gives us the nested behavior you see in the tree, all from one simple component.
      </div>
   </div>
</body>

</html>
