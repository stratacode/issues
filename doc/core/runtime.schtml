<html extends="DocPage">
<head title="StrataCode Build and Runtime"/>

<body>

   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## StrataCode Build and Runtime Overview

The sc command generates any changed code, compiles changed java, and runs main methods and starts processes, or opens urls pulled in by dependent layers.  It's goal is to be an easy way to validate and run any configuration of layers efficiently.  It maintains an index of all generated code so it can validate itself and clean up after itself from run to run.  

You provide the sc command the layer or set of layers you want to run.  Each layer includes its dependent layers automatically.  If you run "sc a b c" it applies the layers in that order - so c is the last layer.  This is called "the build layer".  The results are by default stored in the last layer's build or dynbuild directories depending on whether the last layer is compiled or dynamic. 

If your layers are stored under different root directories, set the layerPath to include each root using the -lp option.  When searching for a layer directory, the directories in the layer path are searched in order like Java's classpath.  You can then use layer names relative to the directory in the layer path.  

The layer path cannot contain zip or jar files currently.  They must be expanded directories.

## Dynamic and Compiled Layers

A layer becomes dynamic when you prefix the layer's name with the dynamic attribute in its definition file or use the -dyn option before the layer name on the command line.  A layer which extends another dynamic layer either directly or indirectly is also by definition dynamic.  As your system system evolves, you typically make layers dynamic during development, then remove the dynamic keyword and compile them into the core for deployment.  

Using the -dyn option helps you temporarily run the system with one or more layers as dynamic.  

## Running StrataCode Applications With the Interpreter

To run any StrataCode application, just run sc with the relative path name of the layers involved.  You set the -lp (layer path) option to include the layer root directories.  StrataCode searches for the first layer definition file which matches the layer name you provide.  It then figures out what needs to be compiled, compiles it if necessary and then runs the main all in the same JVM.  If you specify the -dyn option, any layer names you provide are treated as dynamic layers even if they do not have the dynamic keyword.

Be careful when you save changes using either the editor or the command line interpreter.  It's possible that you've just changed source files in your layers folder.  If you run sc with the -i option, by default all changes go into a new temporary layer, a safe sandbox for making any change.

## The StrataCode Classpath

When you start the sc command, you specify a classpath used to find precompiled classes.  These core classes can be used by any of the layers using Java's normal import mechanism.  You can't use the modify operator with these classes except to set annotations in explicitly designated annotation layers.

Layers can add to the system classpath to include any classes they require for their runtime.

As a convenience, if you use the @MainSettings annotation to specify a run script for your applications main method(s), or extend a framework that does, StrataCode will put the classpath into the generated run scripts for your application.  When your application consists of only compiled layers, you can run with only the core StrataCode runtime, only a small amount of code needed when you use data binding etc.  In this environment StrataCode generates the run script to run your standalone application.

## StrataCode Initialization

If you are customizing a StrataCode framework, you might be interested in the gory details of how layers are initialized.  For everyone else, you run "sc <list-of-layers>".  Your code gets called when it should by the framework.

The sc process goes through the following initialization phases:

* Finds all layer definition files, and the extended layers computes the list of initial system layers
* Sorts the list in dependency order - detects and flags cycles as errors.  When there are no dependencies between two layers, compiled layers are put in front of dynamic layers, and framework layers are put ahead of application layers.
* Constructs each layer object and call the initialize method in each Layer. 
* Computes the runtimes required for this list of layers (e.g. java only, js only, or java and js)
* Finds the first build layer in the stack for the first runtime and starts all layers before the build layer.
* When starting a layer the layer first adds any repository packages it depends on.  Those packages are installed if necessary via git, http, or maven, gradle, etc.
* The layer then updates its library classpath to include pre-compiled jars it depends on.  The library classpath is added to the system immediately after the layer is started.
* Once all layers prior to the build layer are started, the build layer computes the set of top-level directories to prepare (if necessary as in android) and then process.  The pre-process phase is used to generate any .java files that need to exist for the main Java files to be parsed and compiled (e.g. android's resource files).
* For each required phase the .dep file for that phase is used to direct the incremental compile.  This file contains a cache of all source files, the generated files made from those source files, and any dependencies detected in the code on other types.  If this file is not found, the global BuildInfo is not found, or the set of layers used to do the last build has changed, a full build is performed.
* Any files that have changed since the last build are re-parsed and the .dep files are updated with new dependencies.
* For StrataCode files or Java files that are pre-processed, the new Java file is generated into the buildSrc directory - (e.g. buildLayer/build/java or buildLayer/build/js)
* All changed files are compiled by javac or the internal java compiler.
* Any processing specific to the current runtime is performed - e.g. generating Javascript files from the Java
* This process is repeated for each build layer in each runtime until the final build layer in each runtime reached.  Once each buildLayer is compiled, it's buildDir is added to the system classpath in front of any previous build layers.  SC only loads the compiled version for a class once it's determined that class will no longer be modified in a subsequent build layer.  That way, it is ensured it always has the right compiled version of each class.
* If any errors have occurred sc exits (or optionally prompts to retry the build to speed up the fix-recompile process)
* Upon a successful build, sc starts the interpreter and any Main methods and postBuild commands that were registered in the framework layers.  If you use the -c option, it compiles but does not run your application.  It's easy to have StrataCode generate a shell script and the requisite jar file to run and deploy your app as a standard Java application.

## Options

You can force all files to be compiled with the -a option or compile a specific file with the -f option.   

The -cp option sets the classpath StrataCode uses to find binary descriptions of classes.

The -lp option specifies the layer path.

The -v family of options: -vs, -vsa, -vb, -vba, -vh, -vha turn on verbose for sync, data binding, and html respectively.

By default, sc runs all main classes defined in framework layers, after compiling by loading the generated classes into the same VM.  The -rs option execs the scripts generated by the main commands.  The -r pattern option lets you only run main methods matching a specific pattern.  Each of the -r options consumes the remaining options and provides them to the executed command.  If you use -nr it suppresses running of main.

If you use the -nw option, it suppresses the opening of the default browser window for a Javascript application.

The -t option is like -r but runs tests.  You can specify an individual class name, or a pattern matching all test classes (e.g. -t .* to run all tests or just use -ta)

More information can be found in the Javadoc for the LayeredSystem class or with sc -help.

## Layer Properties

When building framework layers, the starting point for customization is the layer definition file.  The layer definition file has logic that would ordinarily be in an ant file or buried in some file your IDE maintains per project.  Because framework layers are shared by application layers, you do not have to specify this information for each project.  And yet all options can be adjusted by downstream layers so they are always configurable as necessary.  

The most common thing framework layers do is to add compiled class files to the classpath.  Classes added this way cannot yet be modified with the modify operation but are available otherwise as normal StrataCode types.  

Layer definition files also can import classes which are then visible without explicit imports in downstream code (unless a layer along the chain sets "inheritImports=false" to turn that off).

More options:

### buildDir

Specifies the buildDirectory where .class files go.  By default, it is the build directory in the layer's folder itself.  This way, the layer is completely self contained.  Clearly the build directory itself cannot contain source.

### buildSrcDir

Specifies the directory where generated .java files go. 

### buildLayer

Any layer which has a build directory is considered to have buildLayer=true by default.  Any layer without a build directory has buildLayer=false unless set explicitly in the layer definition file, or built explicitly (sc [-c] layerName).  Any buildLayer=true layer compiles all files that have changed since any previous buildLayer.  In other words, buildLayers are themselves chained, the latter inheriting the contents of the former.  This lets you share compiled versions of some layers with subsequent layers so you can optimize what gets built when you change a given layer.

### buildSeparate

By default, .sc files in a layer cannot be used as compiled classes in the layer definition file.  Occasionally you need to do this in a layer.  If you mark that layer with buildSeparate, it is compiled and its classes are put into the classpath of the system before subsequent layer def files are processed allowing them to find these classes.  This means that you cannot replace those classes though with the modify operation.  Structurally StrataCode assumes you cannot reload a .java .class file since, though technically some JVMs do allow limited versions of class reloading

### classPath

Java jar files or directories containing .class files in package organization.  The list of jars/directories you add is searched in order to find classes available to code in this layer or any downstream layers.  Once a layer's classpath has been searched, it looks for any classes defined in layers that layer extends.  Thus a downstream layer can override a compiled class in an upstream layer, but only if that layer and class file are in place the first time that class is accessed.  StrataCode does not unload any class files, except as normally garbage collected by the JVM, so a restart is required when you add a new layer with compiled classes in it that override classes that have already been loaded.

### exportImports

Default is true.

Should the imports in the layer file be visible to layers which extend this layer

### inheritImports

Default is true.

Should this layer use the imports from any extended layers.

### inheritPackage

Default is true.

Should this layer use the package prefix of its extend layers?  If there are more than one conflicting package prefix in the list of extend layers, the last one wins.

### copyPlainJavaFiles

Default is true.

Any Java files do not use any extensions are not modified.  They can either be compiled from the source directory or copied into the build directory.  Doing the later ensures you have a single folder containing the entire source for your project, nice if you are editing the Java files with an IDE.  

### excludedFiles

A list of Java regular expressions for files to ignore during the build process.  By default:

       public List<String> excludedFiles = Arrays.asList("build", "out", ".*.sctd", ".git");

StrataCode will ordinarily ignore files which are not in a language it understands.  The "sctd" files are in this list because it currently does not compile those files, they are interpreted instead.  That will be removed once they are compiled like normal StrataCode/Java files.

### compiledOnly

Indicates this layer does not support dynamic mode.  Any attempt to make it dynamic is ignored and all of the files are compiled anyway.   You can turn off dynamic mode on a per class basis using the CompilerSettings annotation.

### transparent

When you mark a layer as transparent, it only affects how the editor displays the types for that layer.  It does not affect the runtime behavior of the application.  A transparent layer shows all objects and properties defined in the layers which the transparent layer extends.  It includes properties in other transparent layers found along the way and so works recursively.  

### useGlobalImports

By default a layer only sees the imports which are defined by layers which it extends, either directly or indirectly.  An import defined in a totally independent layer would not be accessible.  There are some cases however where you might want to define a global layer that can see all base layers without having to extend a bunch of layers explicitly.  For example, the temporary layer created with the -i option can see and modify any type.  For these layers, set useGlobalImports=true so that they can see all of the imports as well.

### codeType and codeFunction

Two metadata properties stored in the layer for use by the editor.  Lets you tag layers as having certain types of code assets (e.g. declarative only) or certain types of code functions (i.e. UI, style, domain model, etc.)

### Adding Code in a Layer

The layer definition file is interpreted so you do not want to do a ton of initialization code in there.  It is a good place though to register framework hooks that are only needed when that layer is included. 

There are three phases for the layer's initialization:

* the instance of sc.layer.Layer is created and all properties are initialized
* the initialize method on all layers is called
* the start method on all layers is called

All layers are initialized up front in the order they exist in the layer stack.  Use your initialize method to add any new runtimes required for this layer or add runtime dependencies.  You also can use the initialize method to modify properties set by a downstream layer used in the start method.  Layers can be used to define and refine build state in an organized way so downstream layers can modify state set up by upstream layers.  That build state can be used in the start methods, before the classpath for the layer is defined.  In practice, this setup makes for a flexible build system that requires minimum configuration copying for each layer.

<% ) %>

     </div>
   </div>
</body>
</html>
