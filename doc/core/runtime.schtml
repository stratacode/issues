<html extends="DocPage">

<body>

   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## StrataCode Build and Runtime Overview

The sc command generates any changed code, compiles changed java, and runs main methods and starts processes, or opens urls pulled in by dependent layers.  It's goal is to be an easy way to run a specific configuration efficiently.  It maintains an index of all generated code so it can validate itself and clean up after itself.  You point it at the layer or set of layers you want to run.  Each layer includes its dependent layers automatically.  If you run "sc a b c" it applies the layers in that order - so c is the most specific layer, the one that will be built unless it is dynamic.

If your layers are stored under different root directories, set the layerPath to include each root.  When searching for a layer directory, the directories in the layer path are searched in order like Java's classpath.  You can then use layer names relative to the directory in the layer path.  Layer directories today may not be accessed in a zip or jar format.

## Dynamic and Compiled Layers

A layer becomes dynamic when you prefix the layer's name with the dynamic attribute in its definition file.  A layer which extends another dynamic layer either directly or indirectly is also by definition dynamic.  As your system system evolves, you typically make layers dynamic during development, then remove the dynamic keyword and compile them into the core for deployment.  

When you start StrataCode, you may specify that one or more layers be made dynamic even if its definition is missing the dynamic keyword.  This helps you test or temporarily run the system with one or more layers as dynamic.  There are several ways to do this from the command line option:

* -dyn: any layers specified after the argument (and those they extend) are forced to be dynamic even when missing the dynanimc keyword in their layer definition file (unless they have compiledOnly=true in their definition).  Any non-loaded layers extended by a -dyn layer are made dynamic when they are loaded.  So for example, to run the editor/swing/main layer as a compiled application but to run the unitConverter sample entirely dynamic you can specify:  

    sc editor/swing/main -dyn example/unitConverter/swingui

* -dynall: any layers specified on the command line and any layers they bring in are forced to be dynamic, unless those layers have Layer.compiledOnly set to true.  
* -dynone layer1, layer2    Only layer1 is made dynamic.  layer2 will be compiled.

## Running StrataCode Applications With the Interpreter

To run any StrataCode application, just run sc with the relative path name of the layers involved.  You set the -lp (layer path) option to include the layer root directories.  StrataCode searches for the first layer definition file which matches the layer name you provide.  It then figures out what needs to be compiled, compiles it if necessary and then runs the main all in the same JVM.  If you specify the -dyn option, any layer names you provide are treated as dynamic layers even if they do not have the dynamic keyword.

Be careful when you save changes using either the editor or the command line interpreter.  It's possible that you've just changed source files in your layers folder.  If you run sc with the -i option, by default all changes go into a new temporary layer, a safe sandbox for making any change.

## The StrataCode Classpath

When you start the sc command, you specify a classpath used to find precompiled classes.  These core classes can be used by any of the layers using Java's normal import mechanism.  You can't use the modify operator with these classes except to set annotations in explicitly designated annotation layers.

Layers can add to the system classpath to include any classes they require for their runtime.

As a convenience, if you use the @MainSettings annotation to specify a run script for your applications main method(s), or extend a framework that does, StrataCode will put the classpath into the generated run scripts for your application.  When your application consists of only compiled layers, you can run with only the core StrataCode runtime, only a small amount of code needed when you use data binding etc.  In this environment StrataCode generates the run script to run your standalone application.

## StrataCode Initialization

If you are customizing a StrataCode framework, you might be interested in the gory details of how layers are initialized.  For everyone else, you run "sc <list-of-layers>".  Your code gets called when it should by the framework.

The sc process goes through the following initialization phases:

* Finds all layer definition files, expands them and computes the list of initial system layers
* Sorts the list in dependency order - detects and flags cycles as errors
* Parses and initializes the list of layers by interpreting the .sc definition files
* Builds the set of top-level folders to compile
* Reads the process.dep file in the build dir.  If not found, gets list of all compileable files
* Any files that have changed since the last build are re-parsed and the process.dep is updated.
* If any Java extensions are required, the new Java file is generated into the buildSrc directory.
* All changed files are compiled by javac or the internal java compiler.
* At this point, sc either exits or starts the interpreter or a Main.  If it starts, it flushes its type cache and adds the build directory to its visible classpath.  Any dependent classes used during compilation have been loaded but not yet resolved.  At this point, Java will just resolve those classes normally as they have been used by the system.
* If you run the interpreter, StrataCode will load the source definitions for any types as necessary to give you the richest description of the application.  This lets it for example detect property initialization cycles and things like that, information that is harder to get from the .class representation.

Note: for some frameworks like android require a "prepare" phase.  This is a pass over the source code performed before the "process" phase to deal with any files which may generate Java code needed for the normal process phase.  If so, the prepare phase runs before the process phase for any file processors registered.

## Options

You can force all files to be compiled with the -a option or compile a specific file with the -f option.   

The -cp option sets the classpath StrataCode uses to find binary descriptions of classes.

The -lp option specifies the layer path.

By default, sc runs all main classes defined in framework layers, after compiling by loading the generated classes into the same VM.  The -rs option execs the scripts generated by the main commands.  The -r pattern option lets you only run main methods matching a specific pattern.  Each of the -r options consumes the remaining options and provides them to the executed command.  If you use -nr it suppresses running of main.

The -t option is like -r but runs tests.  You can specify an individual class name, or a pattern matching all test classes (e.g. -t .* to run all tests or just use -ta)

More information can be found in the Javadoc for the LayeredSystem class or with sc -help.

## Layer Properties

When building framework layers, the starting point for customization is the layer definition file.  The layer definition file has logic that would ordinarily be in an ant file or buried in some file your IDE maintains per project.  Because framework layers are shared by application layers, you do not have to specify this information for each project.  And yet all options can be adjusted by downstream layers so they are always configurable as necessary.  

The most common thing framework layers do is to add compiled class files to the classpath.  Classes added this way cannot yet be modified with the modify operation but are available otherwise as normal StrataCode types.  

Layer definition files also can import classes which are then visible without explicit imports in downstream code (unless a layer along the chain sets "inheritImports=false" to turn that off).

More options:

### buildDir

Specifies the buildDirectory where .class files go.  By default, it is the build directory in the layer's folder itself.  This way, the layer is completely self contained.  Clearly the build directory itself cannot contain source.

### buildSrcDir

Specifies the directory where generated .java files go. 

### buildLayer

Any layer which has a build directory is considered to have buildLayer=true by default.  Any layer without a build directory has buildLayer=false unless set explicitly in the layer definition file, or built explicitly (sc [-c] layerName).  Any buildLayer=true layer compiles all files that have changed since any previous buildLayer.  In other words, buildLayers are themselves chained, the latter inheriting the contents of the former.  This lets you share compiled versions of some layers with subsequent layers so you can optimize what gets built when you change a given layer.

### buildSeparate

By default, .sc files in a layer cannot be used as compiled classes in the layer definition file.  Occasionally you need to do this in a layer.  If you mark that layer with buildSeparate, it is compiled and its classes are put into the classpath of the system before subsequent layer def files are processed allowing them to find these classes.  This means that you cannot replace those classes though with the modify operation.  Structurally StrataCode assumes you cannot reload a .java .class file since, though technically some JVMs do allow limited versions of class reloading

### classPath

Java jar files or directories containing .class files in package organization.  The list of jars/directories you add is searched in order to find classes available to code in this layer or any downstream layers.  Once a layer's classpath has been searched, it looks for any classes defined in layers that layer extends.  Thus a downstream layer can override a compiled class in an upstream layer, but only if that layer and class file are in place the first time that class is accessed.  StrataCode does not unload any class files, except as normally garbage collected by the JVM, so a restart is required when you add a new layer with compiled classes in it that override classes that have already been loaded.

### exportImports

Default is true.

Should the imports in the layer file be visible to layers which extend this layer

### inheritImports

Default is true.

Should this layer use the imports from any extended layers.

### inheritPackage

Default is true.

Should this layer use the package prefix of its extend layers?  If there are more than one conflicting package prefix in the list of extend layers, the last one wins.

### copyPlainJavaFiles

Default is true.

Any Java files do not use any extensions are not modified.  They can either be compiled from the source directory or copied into the build directory.  Doing the later ensures you have a single folder containing the entire source for your project, nice if you are editing the Java files with an IDE.  

### excludedFiles

A list of Java regular expressions for files to ignore during the build process.  By default:

       public List<String> excludedFiles = Arrays.asList("build", "out", ".*.sctd", ".git");

StrataCode will ordinarily ignore files which are not in a language it understands.  The "sctd" files are in this list because it currently does not compile those files, they are interpreted instead.  That will be removed once they are compiled like normal StrataCode/Java files.

### compiledOnly

Indicates this layer does not support dynamic mode.  Any attempt to make it dynamic is ignored and all of the files are compiled anyway.   You can turn off dynamic mode on a per class basis using the CompilerSettings annotation.

### transparent

When you mark a layer as transparent, it only affects how the editor displays the types for that layer.  It does not affect the runtime behavior of the application.  A transparent layer shows all objects and properties defined in the layers which the transparent layer extends.  It includes properties in other transparent layers found along the way and so works recursively.  

### useGlobalImports

By default a layer only sees the imports which are defined by layers which it extends, either directly or indirectly.  An import defined in a totally independent layer would not be accessible.  There are some cases however where you might want to define a global layer that can see all base layers without having to extend a bunch of layers explicitly.  For example, the temporary layer created with the -i option can see and modify any type.  For these layers, set useGlobalImports=true so that they can see all of the imports as well.

### codeType and codeFunction

Two metadata properties stored in the layer for use by the editor.  Lets you tag layers as having certain types of code assets (e.g. declarative only) or certain types of code functions (i.e. UI, style, domain model, etc.)

### Adding Code in a Layer

The layer definition file is interpreted so you do not want to do a ton of initialization code in there.  It is a good place though to register framework hooks that are only needed when that layer is included.  For an example look at layers/doc/doc.sc where the "vdoc" extension is added as a new TemplateProcessor.  This TemplateProcessor is an implementation of the TemplateLnguage but with additional semantics.  During code generation time, it translates the "vdoc" suffix into html.  It supports a "markdown" function which you can use to process markdown format inside your file.

<% ) %>

     </div>
   </div>
</body>
</html>
