<html extends="DocPage">
<head title="StrataCode Components"/>

<body>

   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## StrataCode Components

StrataCode has several component features for making Java code more declarative, more concise, and easier to read.  You may be familiar with component frameworks that implement an inversion of control pattern to wire together a graph of objects for later customization.  With StrataCode, these features are all built into the language using the new object operator and simple references between objects.  

With an inversion of control container, you are faced with the choice of doing writing in configuration or code using annotations.  When you need to move from one to the other, it alters the API contract for anyone using that code.  Either way, wiring and error detect happens at startup time, not compile time.

With layers, you have the choice of putting the reference in the original code or configuring it in a new layer.  You can change your mind at any point without affecting consumers of your published layers.  Even if you put a reference into the original source code, it can be overridden with no cost in a subsequent layer.

The layered approach to component assembly provides customization without upfront planning, a solution that improves code reusability substantially.

## Creating Object Instances

StrataCode supports a new "object" operator, like Scala's object in that it defines a new variable that has a type at the same time.  

If the object is a top-level construct in the file:

<% ) %>

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>object myInstance {
}
<% ) %>
StrataCode generates code similar to the following:

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>class myInstance {
    private static myInstance myInstance;
    static myInstance getMyInstance() {
        if (myInstance == null)
            myInstance = new myInstance();
        return myInstance;
    }
}
<% ) %>

<%= MarkDownPage.markDown(%>

StrataCode creates a class for the object with a static property which lazily creates the default instance.   In your code, you can refer to the object with an ordinary variable e.g. 'myInstance'.  At code-generation time, StrataCode will transform that variable into a method call: myInstance.getMyInstance().

Just as Java lets you define inner classes, you can have inner objects:

<% ) %>

<%= sc.lang.SCLanguage.INSTANCE.styleNoTypeErrors(
%>class MyClass {
   object innerObject {
   }
}
<% ) %>

<%= MarkDownPage.markDown(%>
This defines an inner object, with a single instance created for each instance of MyClass.  At code generation time, StrataCode generates an instance variable to hold the instance and a similar getInnerObject method inside of MyClass to lazily create and retrieve the instance.   As an optimization, StrataCode may not generate a class for each inner object.   Many inner objects are just configured instances of some other type and this makes the implementation more efficient.

Framework layers can use inner objects for the parent/child relationship by adding the "setParent" call or constructor parameters during code-generation.

## Properties

Programmers are taught to avoid exposing fields directly in APIs.  Instead Java's convention for properties is to use getX and setX methods to implement a property called X.  You explicitly call the getX or setX method instead of directly manipulating the field so that the implementation can adapt down the road without breaking your code.   The result is good but it's more code to write both to implement and use a property and worse the code is harder to read and use. 

StrataCode simplifies your life by formalizing the Java convention by generating getX and setX methods as needed and converting simple identifiers and assignments to getX and setX method calls as needed in your generated code.  You can define properties and use them as you would Java fields.  StrataCode handles any necessary code-generation and conversion for you automatically.  Your code looks simpler, cleaner and is more efficient.  Use fields knowing that you can write custom getX and setX methods, or have them generated for you later without breaking code.

Frameworks can customize the getX and setX code generated for properties to interact with framework code.   

The data binding system detect when properties are used in data binding expressions and generates getX and setX methods with the proper code to implement the binding.

## Recursive References using @Component

When you initialize fields in a Java class you can only refer to fully initialized objects.  If the state of your object in any way refers to values which refer back to you, your code will either not compile or just not work.  These are called recursive references.  Component frameworks allow them by adding a multi-step initialization process.  Objects are created and registered in the name space, then references are resolved, then initialization hooks are run. 

Programmers try to avoid recursive references because they create less modular code.  But when you need to add one, it can be hard to get around that need.  In the real world, data sometimes flows upstream.  To move these references from Java to the component framework involves rewriting code, configuration, and breaks code using the affected published APIs or configuration hooks.

StrataCode offers a nice alternative.  Add the @Component annotation to your StrataCode class to change the generated Java code to allow that class to use recursive references.  StrataCode transforms your Java code to use a multi-step initialization sequence.  First it creates all instances in the reference graph and sets their member variables so the getX methods work.  Then the instance variables are assigned.  

TODO: Currently the constructor code is run before these complex instance variables are assigned.  Should this be fixed?  It would be nice if by the time constructor code is run, all instance variables are at least assigned.  

You cannot guarantee that all referenced constructors have been run as there's no way to do that in a recursive reference graph.  Instead, you can move code dependent on that into an init method that is called later.  There's also a start method called after all referenced components have been initialized. 

## Customizing Object Lifecycle

A declarative framework that only supports static objects only goes so far.  StrataCode makes the object lifecycle a customization hinge point so the same object operator can create objects with different lifecycles by customizing the generated getX and setX methods for those objects along with other runtime controls.   
When combined with the HTML framework, you can easily control the lifecycle of the page objects by using the scope operator or the @Scope annotation.  

* session scoped: per browser session 
* window scoped: per browser window 
* request scoped: per request (TODO: not yet implemented but should not be difficult.  It will require the complete reset sync to happen essentially on each request, like we do when there's a failover.)
* global scoped: like static instances on the server
* application scoped: per separate application id, typically the page's URL unless your application is built from more than one page. (TODO not yet implemented)

Framework developers have simple hooks for implementing a new scope.  They can override the contents of the getX method generated for a particular base class, class marked with an annotation, or in a layer.  This is controlled both by annotations set on the class, base-class or layer.  Framework layers provide code templates for generating the right getX method for a given type.  For a session scoped type, they find the object in the current session using a thread-local variables to find the current session.  

<% ) %>

     </div>
   </div>
</body>
</html>
