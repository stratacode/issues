<html extends="ArticlePage">
<head title="Synchronization with Layers"/>

<body>
   <div id="content">
       <div id="pageContent" exec="server">

<%= MarkDownPage.markDown(%>

## Synchronization Using Layers

Today client/server programmers commonly use remote procedure calls (RPC) with a serialization protocol like JSON to communicate with the server.  Some languages require that you write code to convert to and from JSON object, others handle that transparently.

The sync framework starts out supporting this type of object level serialization.  Like others it is directed by annotations to control the generated code for classes and properties.  Unlike others, it's easy to debug the serialization code since it exists in the generated source file, not embedded in some library or through byte-code enhancement.

The biggest hassle with direct RPC code is that you have to handle the response asynchronously (at least when you are using an asynchronous paradigm).  Stratacode gives you an option to avoid that code when you use remote methods in data binding expressions.   In this case, it calls the setX method automatically when the async method returns.   You have declarative/functional access to data you retrieve asynchronously, and can cleanly invoke remote methods in response to events even when they are async.  The same data binding expressions will work in either a client/server environment, or local which makes it easier to reuse domain model code, even when the domain model has remote methods.  This is particularly valuable when a business user is editing data-binding expressions that control some combination of client and server functionality.

By it's nature, RPC involves copying state back and forth explicitly.  Programmers have to write that code explicitly and spend a lot of time with tricky code that amounts to reimplementign the same patterns over and over again.  What you are really doing here is synchronizing objects between the client and server.  StrataCode offers a model for doing just that - synchronize objects automatically.

You annotate classes, objects and properties as [synchronized](/javadoc/sc/obj/Sync), or put them in a shared layer and annotate the layer itself with @Sync.  For synchronized layers, StrataCode detects which layers overlap between different processes and generates code to synchronize the overlapping parts back and forth. 

When a type is synchronized, calls are inserted into the code to track instance creation, and synchronized property changes.  Those events are recorded and sent to the client or server on the next sync (i.e. at the end of the request, or at the end of some user-interface interaction).

The synchronization framework lets you build rich, interative apps, with complex graph-based data models with little to no remote procedure calls and no data transfer objects.  The declarative patterns implemented by the sync framework support the most common uses cases - create, update, delete, lazily fetching of references and collections, and more.  When your application needs more control, you can set the @Sync annotation on properties or types to fine-tune the behavior.  If you still need more control, you can fall back to RPC on the same objects.

For ease of debugging and richness of features, the serialization format today is a StrataCode layer.  Before being sent to the browser, the layer is converted to JS so it loads and executes quickly.  It takes more time to generate the JS on the server however so it's not fast for large data sets.  We will build adapters to various serialization formats so you can choose JSON, or a more efficient binary protocol.

Read more in the [documenttion](http://localhost:8080/syncFramework.html).

<% ) %>
   </div>

   </div>
</body>

</html>

